package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// Resource è¡¨ç¤ºå¯ç”¨çš„æœåŠ¡å™¨èµ„æº
type Resource struct {
	ID               string  `json:"id"`
	Name             string  `json:"name"`
	URL              string  `json:"url"`
	Price            float64 `json:"price"`
	AvailableStorage string  `json:"availableStorage"`
	Latency          string  `json:"latency"`
	Location         string  `json:"location"`
	CPU              string  `json:"cpu"`
	Memory           string  `json:"memory"`
}

// DeployRequest éƒ¨ç½²è¯·æ±‚ç»“æ„
type DeployRequest struct {
	SiteID string `json:"site_id" binding:"required"`
}

// DeployResponse éƒ¨ç½²å“åº”ç»“æ„
type DeployResponse struct {
	Success     bool     `json:"success"`
	Message     string   `json:"message"`
	Site        Resource `json:"site"`
	Files       []string `json:"files"`
	StartScript string   `json:"startScript"`
}

// StopRequest åœæ­¢è¯·æ±‚ç»“æ„
type StopRequest struct {
	SiteID string `json:"site_id" binding:"required"`
}

// StatusResponse çŠ¶æ€å“åº”ç»“æ„
type StatusResponse struct {
	Success       bool                  `json:"success"`
	SiteID        string                `json:"site_id"`
	Status        string                `json:"status"`
	ServicesCount int                   `json:"services_count"`
	Metrics       []ServiceInstanceInfo `json:"metrics"`
	Time          string                `json:"time"`
}

// ServiceInstanceInfo æœåŠ¡å®ä¾‹ä¿¡æ¯ï¼Œä¸models/service.goä¿æŒä¸€è‡´
type ServiceInstanceInfo struct {
	ServiceID string `json:"service_id"`
	Gas       int    `json:"gas"`
	Cost      int    `json:"cost"`
	CSCI_ID   string `json:"csci_id"`
	Delay     int    `json:"delay"`
}

// ä»C-SMAæœåŠ¡è·å–çœŸå®çš„èµ„æºä¿¡æ¯
func getRealResourcesFromCSMA() ([]Resource, error) {
	// ç›´æ¥ä»é…ç½®è·å–çœŸå®ç«™ç‚¹åœ°å€ï¼Œè€Œä¸æ˜¯ä»CSCI_IDè§£æ
	site1RealURL := "http://192.168.235.48:8081"
	site2RealURL := "http://192.168.67.159:8085"
	
	resources := []Resource{}
	
	// è·å–Site1çš„å®æ—¶èµ„æºä¿¡æ¯
	site1Info := getRealResourceInfoFromSite(site1RealURL)
	if site1Info != nil {
		site1Info.ID = "site1"
		site1Info.Name = "æœåŠ¡å™¨èŠ‚ç‚¹ Site-1 (Linux)"
		resources = append(resources, *site1Info)
	}
	
	// è·å–Site2çš„å®æ—¶èµ„æºä¿¡æ¯
	site2Info := getRealResourceInfoFromSite(site2RealURL)
	if site2Info != nil {
		site2Info.ID = "site2"
		site2Info.Name = "æœåŠ¡å™¨èŠ‚ç‚¹ Site-2 (Mac)"
		resources = append(resources, *site2Info)
	}
	
	return resources, nil
}

	// è®¡ç®—æ¯ä¸ªç«™ç‚¹çš„å¹³å‡å»¶è¿Ÿ
	avgDelays := make(map[string]int)
	counts := make(map[string]int)
	
	// é‡æ–°éå†æ•°æ®ä»¥è®¡ç®—å»¶è¿Ÿ
	for _, serviceInstances := range csmFullData.AggregatedData {
		for _, instance := range serviceInstances {
			instanceURL := instance.CSCI_ID
			if instanceURL != "" {
				var siteURL string
				// ä»CSCI_IDä¸­æå–åŸºç¡€URL
				parsedURL, err := url.Parse(instanceURL)
				if err == nil && parsedURL.Scheme != "" && parsedURL.Host != "" {
					siteURL = fmt.Sprintf("%s://%s", parsedURL.Scheme, parsedURL.Host)
				} else {
					// å›é€€åˆ°ç®€å•çš„å­—ç¬¦ä¸²å¤„ç†
					for i, ch := range instanceURL {
						if ch == '/' && i > 0 {
							siteURL = instanceURL[:i]
							break
						}
					}
					if siteURL == "" {
						siteURL = instanceURL
					}
				}
				
				siteID := extractSiteIDFromURL(siteURL)
				if siteID == "" {
					siteID = siteURL
				}
				
				avgDelays[siteID] += instance.Delay
				counts[siteID]++
			}
		}
	}
	
	// å°†å¹³å‡å»¶è¿Ÿåº”ç”¨åˆ°ç«™ç‚¹
	for siteID, totalDelay := range avgDelays {
		count := counts[siteID]
		if count > 0 {
			avgDelay := totalDelay / count
			if siteResource, exists := siteMap[siteID]; exists {
				siteResource.Latency = fmt.Sprintf("%dms", avgDelay)
			}
		}
	}

	// è½¬æ¢ä¸ºåˆ‡ç‰‡è¿”å›
	var resources []Resource
	for _, resource := range siteMap {
		resources = append(resources, *resource)
	}

	return resources, nil
}

// getRealResourceInfoFromSite ä»å®é™…ç«™ç‚¹è·å–å®æ—¶èµ„æºä¿¡æ¯
func getRealResourceInfoFromSite(siteURL string) *Resource {
	resource := &Resource{
		ID:               extractSiteIDFromURL(siteURL),
		Name:             fmt.Sprintf("æœåŠ¡å™¨èŠ‚ç‚¹ %s", extractSiteIDFromURL(siteURL)),
		URL:              siteURL,
		Price:            0.5,
		AvailableStorage: "æœªçŸ¥",
		Latency:          "æœªçŸ¥",
		Location:         getLocationFromURL(siteURL),
		CPU:              "æœªçŸ¥",
		Memory:           "æœªçŸ¥",
	}

	// åˆ›å»ºä¸ä½¿ç”¨ä»£ç†çš„å®¢æˆ·ç«¯
	client := &http.Client{
		Transport: &http.Transport{
			Proxy: nil, // ç¦ç”¨ä»£ç†
		},
		Timeout: 5 * time.Second,
	}

	// å°è¯•ä»ç«™ç‚¹çš„resource-statusæ¥å£è·å–ä¿¡æ¯
	resourceStatusURL := siteURL + "/resource-status"
	resp, err := client.Get(resourceStatusURL)
	if err == nil && resp.StatusCode == http.StatusOK {
		defer resp.Body.Close()
		
		var statusData struct {
			Success bool `json:"success"`
			SiteID  string `json:"site_id"`
			Resource struct {
				Total      string `json:"total"`
				Used       string `json:"used"`
				Remaining  string `json:"remaining"`
				UsageRate  string `json:"usage_rate"`
			} `json:"resource"`
			CostConversion string `json:"cost_conversion"`
		}
		
		if err := json.NewDecoder(resp.Body).Decode(&statusData); err == nil && statusData.Success {
			// æ›´æ–°èµ„æºä¿¡æ¯
			resource.AvailableStorage = statusData.Resource.Remaining + " å•ä½"
			resource.CPU = fmt.Sprintf("ä½¿ç”¨ç‡ %s", statusData.Resource.UsageRate)
			resource.Memory = fmt.Sprintf("å·²ç”¨ %s / æ€» %s å•ä½", statusData.Resource.Used, statusData.Resource.Total)
		}
	}

	// å°è¯•ä»ç«™ç‚¹çš„healthæ¥å£è·å–å»¶è¿Ÿä¿¡æ¯
	healthURL := siteURL + "/health"
	resp, err = client.Get(healthURL)
	if err == nil && resp.StatusCode == http.StatusOK {
		defer resp.Body.Close()
		
		var healthData struct {
			Success bool `json:"success"`
			Status  string `json:"status"`
			SiteID  string `json:"site_id"`
			Time    string `json:"time"`
			ResourceStatus struct {
				Status    string `json:"status"`
				Used      string `json:"used"`
				UsageRate string `json:"usage_rate"`
			} `json:"resource_status"`
		}
		
		if err := json.NewDecoder(resp.Body).Decode(&healthData); err == nil && healthData.Success {
			// æ›´æ–°å»¶è¿Ÿä¿¡æ¯
			resource.Latency = "æ­£å¸¸"
			if healthData.ResourceStatus.Status != "healthy" {
				resource.Latency = "è­¦å‘Š: " + healthData.ResourceStatus.Status
			}
		}
	}

	return resource
}

// extractSiteIDFromURL ä»URLä¸­æå–ç«™ç‚¹ID
func extractSiteIDFromURL(urlStr string) string {
	// ä»URLä¸­æå–ç«™ç‚¹IDï¼Œå¯¹äºlocalhostçš„æƒ…å†µï¼Œä½¿ç”¨ç«¯å£æ¥åŒºåˆ†
	parsed, err := url.Parse(urlStr)
	if err != nil {
		return "unknown"
	}
	
	host := parsed.Host
	if host == "" {
		host = parsed.Path // å›é€€åˆ°è·¯å¾„
	}
	
	// å¯¹äºlocalhostï¼ŒåŒ…å«ç«¯å£æ¥åŒºåˆ†ä¸åŒç«™ç‚¹
	if strings.Contains(host, "localhost") || strings.Contains(host, "127.0.0.1") {
		return host // ä¾‹å¦‚: localhost:8082, localhost:8085
	}
	
	// å¯¹äºå…¶ä»–æƒ…å†µï¼Œå»æ‰ç«¯å£å·ä¹‹åçš„éƒ¨åˆ†
	for i, ch := range host {
		if ch == ':' || ch == '/' || ch == '?' || ch == '#' {
			return host[:i]
		}
	}
	
	return host
}

// getLocationFromURL ä»URLè·å–ä½ç½®ä¿¡æ¯
func getLocationFromURL(urlStr string) string {
	// ä»URLæå–ä¸»æœºå’Œç«¯å£ä¿¡æ¯
	parsed, err := url.Parse(urlStr)
	if err != nil {
		return "æœªçŸ¥ä½ç½®"
	}

	host := parsed.Host
	if host == "" {
		host = parsed.Path
	}
	
	// æ ¹æ®ç«¯å£è¿”å›å¯¹åº”çš„ç«™ç‚¹ä¿¡æ¯
	if strings.Contains(host, "localhost:8082") || strings.Contains(host, "127.0.0.1:8082") {
		return "Site-1 (Linux)"
	} else if strings.Contains(host, "localhost:8085") || strings.Contains(host, "127.0.0.1:8085") {
		return "Site-2 (Mac)"
	} else if strings.Contains(host, "localhost") || strings.HasPrefix(host, "127.") {
		return "æœ¬åœ°æœåŠ¡å™¨"
	} else if strings.Contains(host, "192.168") {
		return "å†…ç½‘æœåŠ¡å™¨"
	} else if strings.Contains(host, "10.") || strings.Contains(host, "172.") {
		return "å†…ç½‘æœåŠ¡å™¨"
	}

	// å¦‚æœæ˜¯å…·ä½“çš„IPåœ°å€ï¼Œå¯ä»¥æ ¹æ®IPæ®µæ¨æµ‹ä½ç½®
	// æˆ–è€…å¯ä»¥ä½¿ç”¨IPåœ°ç†ä½ç½®æœåŠ¡æ¥è·å–çœŸå®ä½ç½®ä¿¡æ¯
	return "æœåŠ¡å™¨(" + host + ")"
}

func main() {
	r := gin.Default()

	// è®¾ç½®å¤šéƒ¨åˆ†å½¢å¼ä¸Šä¼ çš„æœ€å¤§å†…å­˜ä¸º 8 MB
	r.MaxMultipartMemory = 8 << 20

	// APIè·¯ç”±ç»„ - é¦–å…ˆå®šä¹‰APIè·¯ç”±ï¼Œé¿å…ä¸é™æ€æ–‡ä»¶è·¯ç”±å†²çª
	api := r.Group("/api")
	{
		api.GET("/resources", getResources)
		api.POST("/deploy", deployCode)
		api.POST("/stop", stopCode)
		api.GET("/status/:siteId", getStatus)
	}

	// é™æ€æ–‡ä»¶æœåŠ¡ï¼Œæä¾›å‰ç«¯é¡µé¢å’Œé™æ€èµ„æºä¸ºç‰¹å®šçš„é™æ€æ–‡ä»¶ç±»å‹æä¾›æœåŠ¡ï¼Œè€Œä¸æ˜¯ä½¿ç”¨é€šé…ç¬¦
	r.StaticFile("/", "./index.html")           // ä¸»é¡µ
	r.StaticFile("/index.html", "./index.html") // æ˜ç¡®æŒ‡å®šindex.html
	r.Static("/static", "./static")             // é™æ€èµ„æºç›®å½•
	r.Static("/assets", "./assets")             // èµ„æºç›®å½•

	// å¦‚æœè¯·æ±‚ä¸æ˜¯APIä¹Ÿä¸æ˜¯é™æ€æ–‡ä»¶ï¼Œåˆ™è¿”å›index.htmlï¼ˆç”¨äºSPAï¼‰
	r.NoRoute(func(c *gin.Context) {
		if c.Request.URL.Path != "/" &&
			!strings.HasPrefix(c.Request.URL.Path, "/api") &&
			!strings.HasPrefix(c.Request.URL.Path, "/static") &&
			!strings.HasPrefix(c.Request.URL.Path, "/assets") {
			c.File("./index.html")
		}
	})

	// å¯åŠ¨æœåŠ¡å™¨
	fmt.Println("ğŸš€ Webç•Œé¢æœåŠ¡å™¨å¯åŠ¨åœ¨ :9091")
	fmt.Println("ğŸŒ è®¿é—® http://localhost:9091 æŸ¥çœ‹ç•Œé¢")
	r.Run(":9091")
}

// getResources è·å–å¯ç”¨èµ„æº
func getResources(c *gin.Context) {
	resources, err := getRealResourcesFromCSMA()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è·å–èµ„æºä¿¡æ¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, resources)
}

// deployCode éƒ¨ç½²ä»£ç åˆ°æŒ‡å®šç«™ç‚¹
func deployCode(c *gin.Context) {
	// è§£æè¡¨å•æ•°æ®
	siteID := c.PostForm("site_id")
	if siteID == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   "å¿…é¡»æŒ‡å®šç«™ç‚¹ID",
		})
		return
	}

	// ä»C-SMAè·å–æœ€æ–°çš„èµ„æºä¿¡æ¯
	availableResources, err := getRealResourcesFromCSMA()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è·å–èµ„æºä¿¡æ¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æŸ¥æ‰¾ç›®æ ‡ç«™ç‚¹
	var targetSite *Resource
	for i := range availableResources {
		if availableResources[i].ID == siteID {
			targetSite = &availableResources[i]
			break
		}
	}

	if targetSite == nil {
		c.JSON(http.StatusNotFound, gin.H{
			"success": false,
			"error":   "æœªæ‰¾åˆ°æŒ‡å®šçš„ç«™ç‚¹",
		})
		return
	}

	// è·å–ä¸Šä¼ çš„æ–‡ä»¶
	file, err := c.FormFile("codeFiles")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   "è·å–ä»£ç æ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	// ç¡®ä¿uploadsç›®å½•å­˜åœ¨
	uploadDir := "./uploads"
	if _, err := os.Stat(uploadDir); os.IsNotExist(err) {
		os.MkdirAll(uploadDir, 0755)
	}

	// ä¿å­˜ä¸Šä¼ çš„ZIPæ–‡ä»¶
	zipFilename := filepath.Join(uploadDir, file.Filename)
	if err := c.SaveUploadedFile(file, zipFilename); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "ä¿å­˜ZIPæ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è¯»å–ZIPæ–‡ä»¶å†…å®¹
	zipData, err := os.ReadFile(zipFilename)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è¯»å–ZIPæ–‡ä»¶å¤±è´¥: " + err.Error(),
		})
		return
	}

	// è¯»å–startScriptå‚æ•°
	startScriptName := c.PostForm("startScript")

	// å°è¯•å°†ä»£ç ä¼ è¾“åˆ°ç›®æ ‡æœåŠ¡å™¨
	err = transferCodeToServer(targetSite.URL, zipData, startScriptName)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "ä¼ è¾“ä»£ç åˆ°æœåŠ¡å™¨å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, DeployResponse{
		Success:     true,
		Message:     fmt.Sprintf("ä»£ç å·²æˆåŠŸéƒ¨ç½²åˆ° %s", targetSite.Name),
		Site:        *targetSite,
		Files:       []string{file.Filename},
		StartScript: startScriptName,
	})
}

// transferCodeToServer å°†ä»£ç ä¼ è¾“åˆ°ç›®æ ‡æœåŠ¡å™¨
func transferCodeToServer(serverURL string, zipData []byte, startScriptName string) error {
	// åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„å¤šéƒ¨åˆ†è¡¨å•
	var body bytes.Buffer
	writer := multipart.NewWriter(&body)

	// æ·»åŠ ZIPæ•°æ®
	part, err := writer.CreateFormFile("file", "code.zip")
	if err != nil {
		return err
	}
	_, err = part.Write(zipData)
	if err != nil {
		return err
	}

	// æ·»åŠ startScriptå‚æ•°
	err = writer.WriteField("startScript", startScriptName)
	if err != nil {
		return err
	}

	err = writer.Close()
	if err != nil {
		return err
	}

	// å‘é€POSTè¯·æ±‚åˆ°ç›®æ ‡æœåŠ¡å™¨çš„ä¸Šä¼ ç«¯ç‚¹
	uploadURL := serverURL + "/upload"
	client := &http.Client{Timeout: 60 * time.Second} // å¢åŠ è¶…æ—¶æ—¶é—´ï¼Œå› ä¸ºå¯èƒ½éœ€è¦ä¸Šä¼ å¤§æ–‡ä»¶
	req, err := http.NewRequest("POST", uploadURL, &body)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// æ£€æŸ¥å“åº”
	respBody, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("ä¼ è¾“ä»£ç å¤±è´¥ï¼ŒçŠ¶æ€ç : %d, å“åº”: %s", resp.StatusCode, string(respBody))
	}

	// è§£æå“åº”
	var uploadResponse struct {
		Success     bool   `json:"success"`
		Message     string `json:"message"`
		ExtractPath string `json:"extractPath"`
		StartScript string `json:"startScript"`
		Error       string `json:"error"`
	}
	if err := json.Unmarshal(respBody, &uploadResponse); err != nil {
		return fmt.Errorf("è§£æä¸Šä¼ å“åº”å¤±è´¥: %v", err)
	}

	if !uploadResponse.Success {
		return fmt.Errorf("ä¸Šä¼ å¤±è´¥: %s", uploadResponse.Error)
	}

	fmt.Printf("âœ… æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: %s\n", uploadResponse.Message)

	// å¦‚æœæœ‰startScriptï¼Œåˆ™åœ¨ç›®æ ‡æœåŠ¡å™¨ä¸Šæ‰§è¡Œå®ƒ
	if startScriptName != "" {
		err = executeStartScriptOnServer(serverURL, startScriptName, uploadResponse.ExtractPath)
		if err != nil {
			return fmt.Errorf("æ‰§è¡Œå¯åŠ¨è„šæœ¬å¤±è´¥: %v", err)
		}
	}

	return nil
}

// executeStartScriptOnServer åœ¨ç›®æ ‡æœåŠ¡å™¨ä¸Šæ‰§è¡Œstart.sh
func executeStartScriptOnServer(serverURL string, startScriptName string, extractPath string) error {
	// åˆ›å»ºæ‰§è¡Œè¯·æ±‚ä½“
	execReq := map[string]string{
		"script":      startScriptName,
		"script_path": extractPath + "/" + startScriptName,
		"work_dir":    extractPath,
	}

	jsonData, err := json.Marshal(execReq)
	if err != nil {
		return err
	}

	client := &http.Client{Timeout: 30 * time.Second}
	req, err := http.NewRequest("POST", serverURL+"/execute", bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		// å¦‚æœæ‰§è¡Œç«¯ç‚¹ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬åªè®°å½•ä¿¡æ¯
		fmt.Printf("âš ï¸ æ— æ³•è°ƒç”¨æ‰§è¡Œç«¯ç‚¹: %v (è¿™åœ¨å½“å‰å®ç°ä¸­æ˜¯æ­£å¸¸çš„)\n", err)
		return nil
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// å¦‚æœè„šæœ¬æ‰§è¡Œç«¯ç‚¹ä¸å­˜åœ¨ï¼Œè¿™ä¹Ÿæ­£å¸¸
		fmt.Printf("âš ï¸ æ‰§è¡Œè„šæœ¬ç«¯ç‚¹ä¸å­˜åœ¨æˆ–ä¸å¯ç”¨ (çŠ¶æ€ç : %d)ï¼Œè¿™åœ¨å½“å‰å®ç°ä¸­æ˜¯æ­£å¸¸çš„\n", resp.StatusCode)
		return nil
	}

	return nil
}

// stopCode åœæ­¢åœ¨æŒ‡å®šç«™ç‚¹ä¸Šè¿è¡Œçš„æœåŠ¡
func stopCode(c *gin.Context) {
	var req StopRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"error":   "è¯·æ±‚æ ¼å¼é”™è¯¯: " + err.Error(),
		})
		return
	}

	// ä»C-SMAè·å–æœ€æ–°çš„èµ„æºä¿¡æ¯
	availableResources, err := getRealResourcesFromCSMA()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è·å–èµ„æºä¿¡æ¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æŸ¥æ‰¾ç›®æ ‡ç«™ç‚¹
	var targetSite *Resource
	for i := range availableResources {
		if availableResources[i].ID == req.SiteID {
			targetSite = &availableResources[i]
			break
		}
	}

	if targetSite == nil {
		c.JSON(http.StatusNotFound, gin.H{
			"success": false,
			"error":   "æœªæ‰¾åˆ°æŒ‡å®šçš„ç«™ç‚¹",
		})
		return
	}

	// å‘é€åœæ­¢è¯·æ±‚åˆ°ç›®æ ‡æœåŠ¡å™¨
	err = sendStopRequestToServer(targetSite.URL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "åœæ­¢æœåŠ¡å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": fmt.Sprintf("å·²åœ¨ %s ä¸Šåœæ­¢æœåŠ¡", targetSite.Name),
	})
}

// sendStopRequestToServer å‘ç›®æ ‡æœåŠ¡å™¨å‘é€åœæ­¢è¯·æ±‚
func sendStopRequestToServer(serverURL string) error {
	client := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequest("POST", serverURL+"/stop", nil)
	if err != nil {
		return err
	}

	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("åœæ­¢æœåŠ¡å¤±è´¥ï¼ŒçŠ¶æ€ç : %d", resp.StatusCode)
	}

	return nil
}

// getStatus è·å–æŒ‡å®šç«™ç‚¹çš„çŠ¶æ€
func getStatus(c *gin.Context) {
	siteID := c.Param("siteId")

	// è·å–æ‰€æœ‰å¯ç”¨èµ„æºï¼ˆä»C-SMAè·å–ï¼‰
	resources, err := getRealResourcesFromCSMA()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è·å–èµ„æºä¿¡æ¯å¤±è´¥: " + err.Error(),
		})
		return
	}

	// æŸ¥æ‰¾ç›®æ ‡ç«™ç‚¹
	var targetSite *Resource
	for i := range resources {
		if resources[i].ID == siteID {
			targetSite = &resources[i]
			break
		}
	}

	if targetSite == nil {
		c.JSON(http.StatusNotFound, gin.H{
			"success": false,
			"error":   "æœªæ‰¾åˆ°æŒ‡å®šçš„ç«™ç‚¹",
		})
		return
	}

	// è·å–ç›®æ ‡æœåŠ¡å™¨çš„æŒ‡æ ‡
	metrics, err := fetchMetricsFromServer(targetSite.URL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"success": false,
			"error":   "è·å–æŒ‡æ ‡å¤±è´¥: " + err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, StatusResponse{
		Success:       true,
		SiteID:        targetSite.ID,
		Status:        "running",
		ServicesCount: len(metrics),
		Metrics:       metrics,
		Time:          time.Now().Format(time.RFC3339),
	})
}

// fetchMetricsFromServer ä»ç›®æ ‡æœåŠ¡å™¨è·å–æŒ‡æ ‡
func fetchMetricsFromServer(serverURL string) ([]ServiceInstanceInfo, error) {
	client := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequest("GET", serverURL+"/metrics", nil)
	if err != nil {
		return nil, err
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("è·å–æŒ‡æ ‡å¤±è´¥ï¼ŒçŠ¶æ€ç : %d", resp.StatusCode)
	}

	var response struct {
		Success bool                  `json:"success"`
		Metrics []ServiceInstanceInfo `json:"metrics"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		return nil, err
	}

	return response.Metrics, nil
}
